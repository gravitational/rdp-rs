use bit_field::BitField;
use bitflags::bitflags;

use crate::model::error::{Error, RdpError, RdpErrorKind, RdpResult};
use std::io::{Cursor, Read};

use byteorder::{BigEndian, ByteOrder, LittleEndian, ReadBytesExt};
use log::debug;
use num_enum::TryFromPrimitive;
use std::convert::TryFrom;

const BITMAPCACHE_WAITING_LIST_INDEX: u16 = 0x7FFF;

#[derive(Debug)]
pub enum DrawingOrder {
    PrimaryDrawingOrder(PrimaryDrawingOrder),
    DrawingOrderSecondary(DrawingOrderSecondary),
    AlternateSecondary,
}

#[repr(u8)]
#[derive(Debug, TryFromPrimitive, Copy, Clone, Eq, PartialEq)]
pub enum PrimaryOrderType {
    DstBlt = 0x00,
    PatBlt = 0x01,
    ScrBlt = 0x02,
    DrawNineGrid = 0x07,
    MultiDrawNineGrid = 0x08,
    LineTo = 0x09,
    OpaqueRect = 0x0A,
    SaveBitmap = 0x0B,
    MemBlt = 0x0D,
    Mem3Blt = 0x0E,
    MultiDstBlt = 0x0F,
    MultiPatBlt = 0x10,
    MultiScrBlt = 0x11,
    MultiOpaqueRect = 0x12,
    FastIndex = 0x13,
    PolygonSC = 0x14,
    PolygonCB = 0x15,
    Polyline = 0x16,
    FastGlyph = 0x18,
    EllipseSC = 0x19,
    EllipseCB = 0x1A,
    GlyphIndex = 0x1B,
}

#[repr(u8)]
#[derive(Debug, TryFromPrimitive, Copy, Clone, Eq, PartialEq)]
enum SecondaryOrderType {
    CacheBitmapUncompressed = 0x00,
    CacheColorTable = 0x01,
    CacheBitmapCompressed = 0x02,
    CacheGlyph = 0x03,
    CacheBitmapUncompressedRev2 = 0x04,
    CacheBitmapCompressedRev2 = 0x05,
    CacheBrush = 0x07,
    CacheBitmapCompressedRev3 = 0x08,
}

bitflags! {
    struct FlagDrawingOrder: u8 {
        const TS_STANDARD = 0x01;
        const TS_ALTERNATE = 0x2;
        const TS_SECONDARY = 0x03;
        const TS_BOUNDS = 0x04;
        const TS_TYPE_CHANGE = 0x08;
        const TS_DELTA_COORDINATES = 0x10;
        const TS_ZERO_BOUNDS_DELTAS = 0x20;
        const TS_ZERO_FIELD_BYTE_BIT0 = 0x40;
        const TS_ZERO_FIELD_BYTE_BIT1 = 0x80;
    }
}

#[derive(Default, Debug)]
pub struct CacheBitmapCompressedRev2 {
    pub bits_per_pixel: u16,
    pub width: u16,
    pub height: u16,
    pub cache_id: u16,
    pub cache_index: u16,
    pub persistent_cache_key: Option<u64>,
    pub data: Vec<u8>,
}

// TODO:
#[derive(Default, Debug)]
#[allow(dead_code)]
pub struct CacheColorTable {
    cache_index: u8,
}

bitflags! {
    struct CacheBitmapCompressedRev2Flags: u16 {
        const HEIGHT_SAME_AS_WIDTH = 0x01;
        const PERSISTENT_KEY_PRESENT = 0x02;
        const NO_BITMAP_COMPRESSION_HDR = 0x08;
        const DO_NOT_CACHE = 0x10;
    }
}

#[repr(u8)]
#[derive(Debug, TryFromPrimitive, Copy, Clone, Eq, PartialEq)]
enum BitsPerPixelFlag {
    CBR2_8BPP = 0x3,
    CBR2_16BPP = 0x4,
    CBR2_24BPP = 0x5,
    CBR2_32BPP = 0x6,
}

#[derive(Debug, Default)]
pub struct PrimaryDrawingOrderHistory {
    pub order_type: Option<PrimaryOrderType>,
    // todo: bounding rectangle
    pub mem_blt: Option<MemBlt>,
    pub scr_blt: Option<ScrBlt>,
}

#[derive(Debug)]
pub enum DrawingOrderSecondary {
    CacheBitmapCompressedRev2(CacheBitmapCompressedRev2),
    CacheColorTable(CacheColorTable),
}

impl DrawingOrderSecondary {
    fn from_bytes(orders_data: &mut Cursor<&[u8]>) -> RdpResult<Self> {
        let _order_length = orders_data.read_u16::<LittleEndian>()?;
        let extra_flags = orders_data.read_u16::<LittleEndian>()?;
        let order_type = orders_data.read_u8()?;

        match SecondaryOrderType::try_from(order_type)? {
            SecondaryOrderType::CacheBitmapCompressedRev2 => {
                let cache_id = extra_flags & !0xFFF8;
                let bits_per_pixel =
                    match BitsPerPixelFlag::try_from(((extra_flags >> 3) & !0xFFF0) as u8)? {
                        BitsPerPixelFlag::CBR2_8BPP => 8,
                        BitsPerPixelFlag::CBR2_16BPP => 16,
                        BitsPerPixelFlag::CBR2_24BPP => 24,
                        BitsPerPixelFlag::CBR2_32BPP => 32,
                    };

                let flags = CacheBitmapCompressedRev2Flags::from_bits_truncate(
                    (extra_flags >> 7) & !0xFE00,
                );

                let persistent_cache_key =
                    if flags.contains(CacheBitmapCompressedRev2Flags::PERSISTENT_KEY_PRESENT) {
                        Some(orders_data.read_u64::<LittleEndian>()?)
                    } else {
                        None
                    };

                let width = two_byte_unsigned(orders_data)?;
                let height = if flags.contains(CacheBitmapCompressedRev2Flags::HEIGHT_SAME_AS_WIDTH) {
                    width
                } else {
                    two_byte_unsigned(orders_data)?
                };

                let bitmap_length = four_byte_unsigned(orders_data)?;
                let cache_index = two_byte_unsigned(orders_data)?;

                if flags.contains(CacheBitmapCompressedRev2Flags::DO_NOT_CACHE)
                    && cache_index != BITMAPCACHE_WAITING_LIST_INDEX
                {
                    return Err(Error::TryError(format!(
                        "invalid cache index, expected: {:} got: {:}",
                        BITMAPCACHE_WAITING_LIST_INDEX, cache_index
                    )));
                };

                if !flags.contains(CacheBitmapCompressedRev2Flags::NO_BITMAP_COMPRESSION_HDR) {
                    let _cb_comp_first_row_size = orders_data.read_u16::<LittleEndian>()?;
                    let _cb_comp_main_body_size = orders_data.read_u16::<LittleEndian>()?;
                    let _cb_scan_width = orders_data.read_u16::<LittleEndian>()?;
                    let _cb_uncompressed_size = orders_data.read_u16::<LittleEndian>()?;
                }

                let mut data: Vec<u8> = vec![0; bitmap_length as usize];
                orders_data.read_exact(&mut data)?;

                return Ok(DrawingOrderSecondary::CacheBitmapCompressedRev2(
                    CacheBitmapCompressedRev2 {
                        cache_id,
                        cache_index,
                        persistent_cache_key,
                        width,
                        height,
                        bits_per_pixel,
                        data,
                    },
                ));
            }
            SecondaryOrderType::CacheColorTable => {
                // TODO:
                let order = CacheColorTable { cache_index: 1 };
                return Ok(DrawingOrderSecondary::CacheColorTable(order));
            }
            _ => {
                return Err(Error::RdpError(RdpError::new(
                    RdpErrorKind::NotImplemented,
                    &format!("SecondaryOrderType {:?} not implemented", order_type),
                )))
            }
        }
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct MemBlt {
    pub cache_id: u8,
    pub cache_index: u16,
    pub color_table_id: u8,
    pub n_left_rect: i32,
    pub n_top_rect: i32,
    pub n_width: i32,
    pub n_height: i32,
    pub b_rop: u8,
    pub n_x_src: i32,
    pub n_y_src: i32,
}

#[derive(Debug, Default, Clone, Copy)]
pub struct ScrBlt {
    pub n_left_rect: i32,
    pub n_top_rect: i32,
    pub n_width: i32,
    pub n_height: i32,
    pub b_rop: u8,
    pub n_x_src: i32,
    pub n_y_src: i32,
}

#[derive(Debug)]
pub enum PrimaryDrawingOrder {
    MemBlt(MemBlt),
    ScrBlt(ScrBlt),
    Unknown,
}

impl PrimaryDrawingOrder {
    fn from_bytes(
        data: &mut Cursor<&[u8]>,
        flags: FlagDrawingOrder,
        orders_history: &mut PrimaryDrawingOrderHistory,
    ) -> RdpResult<Self> {
        let primary_order_type = if flags.contains(FlagDrawingOrder::TS_TYPE_CHANGE) {
            PrimaryOrderType::try_from(data.read_u8()?)?
        } else {
            if let Some(order_type) = orders_history.order_type {
                order_type
            } else {
                return Err(Error::RdpError(RdpError::new(
                    RdpErrorKind::InvalidData,
                    &format!(
                        "got primary drawing order without type, but order_history type is empty"
                    ),
                )));
            }
        };

        let field_flag_number_of_bytes_to_remove: u32 = if flags.contains(
            FlagDrawingOrder::TS_ZERO_FIELD_BYTE_BIT1 | FlagDrawingOrder::TS_ZERO_FIELD_BYTE_BIT0,
        ) {
            3
        } else if flags.contains(FlagDrawingOrder::TS_ZERO_FIELD_BYTE_BIT1) {
            2
        } else if flags.contains(FlagDrawingOrder::TS_ZERO_FIELD_BYTE_BIT0) {
            1
        } else {
            0
        };

        // TODO:
        let remove = match primary_order_type {
            PrimaryOrderType::ScrBlt => 7.0,
            PrimaryOrderType::MemBlt => 9.0,
            _ => 9.0,
        };

        let field_flags_number_of_bytes_to_read =
            f32::ceil((remove + 1.0) / 8.0) as u32 - field_flag_number_of_bytes_to_remove;

        let field_flags: u32 = match field_flags_number_of_bytes_to_read {
            3 => {
                let f1 = data.read_u8()?;
                let f2 = data.read_u8()?;
                let f3 = data.read_u8()?;
                BigEndian::read_u32(&[0, f3, f2, f1])
            }
            2 => {
                let f1 = data.read_u8()?;
                let f2 = data.read_u8()?;
                BigEndian::read_u32(&[0, 0, f2, f1]) as u32
            }
            1 => BigEndian::read_u32(&[0, 0, 0, data.read_u8()?]) as u32,
            _ => 0,
        };

        // TODO: calculate if there is enough data
        match primary_order_type {
            PrimaryOrderType::MemBlt => {
                let mut order = match orders_history.mem_blt {
                    Some(order) => order,
                    None => MemBlt::default(),
                };
                if field_flags.get_bit(0) {
                    order.cache_id = data.read_u8()?;
                    order.color_table_id = data.read_u8()?;
                };
                let delta_coordinates = flags.contains(FlagDrawingOrder::TS_DELTA_COORDINATES);

                if field_flags.get_bit(1) {
                    order.n_left_rect = coord_field(data, order.n_left_rect, delta_coordinates)?;
                };

                if field_flags.get_bit(2) {
                    order.n_top_rect = coord_field(data, order.n_top_rect, delta_coordinates)?;
                };

                if field_flags.get_bit(3) {
                    order.n_width = coord_field(data, order.n_width, delta_coordinates)?;
                };

                if field_flags.get_bit(4) {
                    order.n_height = coord_field(data, order.n_height, delta_coordinates)?;
                };

                if field_flags.get_bit(5) {
                    order.b_rop = data.read_u8()?;
                };

                if field_flags.get_bit(6) {
                    order.n_x_src = coord_field(data, order.n_x_src, delta_coordinates)?;
                };

                if field_flags.get_bit(7) {
                    order.n_y_src = coord_field(data, order.n_y_src, delta_coordinates)?;
                };

                if field_flags.get_bit(8) {
                    order.cache_index = data.read_u16::<LittleEndian>()?;
                };

                orders_history.order_type = Some(PrimaryOrderType::MemBlt);
                orders_history.mem_blt = Some(order);

                Ok(PrimaryDrawingOrder::MemBlt(order))
            }

            PrimaryOrderType::ScrBlt => {
                let mut order = match orders_history.scr_blt {
                    Some(order) => order,
                    None => ScrBlt::default(),
                };
                let delta_coordinates = flags.contains(FlagDrawingOrder::TS_DELTA_COORDINATES);

                if field_flags.get_bit(0) {
                    order.n_left_rect = coord_field(data, order.n_left_rect, delta_coordinates)?;
                };

                if field_flags.get_bit(1) {
                    order.n_top_rect = coord_field(data, order.n_top_rect, delta_coordinates)?;
                };

                if field_flags.get_bit(2) {
                    order.n_width = coord_field(data, order.n_width, delta_coordinates)?;
                };

                if field_flags.get_bit(3) {
                    order.n_height = coord_field(data, order.n_height, delta_coordinates)?;
                };

                if field_flags.get_bit(4) {
                    order.b_rop = data.read_u8()?;
                };

                if field_flags.get_bit(5) {
                    order.n_x_src = coord_field(data, order.n_x_src, delta_coordinates)?;
                };

                if field_flags.get_bit(6) {
                    order.n_y_src = coord_field(data, order.n_y_src, delta_coordinates)?;
                };

                orders_history.order_type = Some(PrimaryOrderType::ScrBlt);
                orders_history.scr_blt = Some(order);
                Ok(PrimaryDrawingOrder::ScrBlt(order))
            }
            _ => {
                orders_history.order_type = Some(primary_order_type);
                Ok(PrimaryDrawingOrder::Unknown)
            }
        }
    }
}

fn coord_field(data: &mut impl Read, last_value: i32, delta: bool) -> RdpResult<i32> {
    if delta {
        Ok(last_value + data.read_i8()? as i32)
    } else {
        Ok(data.read_u16::<LittleEndian>()? as i32)
    }
}

fn two_byte_unsigned(data: &mut impl Read) -> RdpResult<u16> {
    let first_byte = data.read_u8()?;
    let mask = 0b10000000;

    match first_byte >> 7 {
        0 => Ok((first_byte & !mask) as u16),
        1 => Ok(BigEndian::read_u16(&[first_byte & !mask, data.read_u8()?])),
        _ => Err(Error::TryError(String::from(
            "couldn't parse TWO_BYTE_UNSIGNED_ENCODING structure",
        ))),
    }
}

fn four_byte_unsigned(data: &mut impl Read) -> RdpResult<u32> {
    let first_byte = data.read_u8()?;
    let mask = 0b11000000;

    match first_byte >> 6 {
        0 => Ok((first_byte & !mask) as u32),
        1 => Ok(BigEndian::read_u32(&[0, 0, first_byte & !mask, data.read_u8()?]) as u32),
        2 => Ok(
            BigEndian::read_u32(&[0, first_byte & !mask, data.read_u8()?, data.read_u8()?]) as u32,
        ),
        3 => Ok(BigEndian::read_u32(&[
            first_byte & !mask,
            data.read_u8()?,
            data.read_u8()?,
            data.read_u8()?,
        ]) as u32),
        _ => Err(Error::TryError(String::from(
            "couldn't parse FOUR_BYTE_UNSIGNED_ENCODING structure",
        ))),
    }
}

pub fn process_orders_data(
    order_count: u16,
    orders_data: &mut Cursor<&[u8]>,
    orders_history: &mut PrimaryDrawingOrderHistory,
) -> RdpResult<Vec<DrawingOrder>> {
    let mut drawing_orders: Vec<DrawingOrder> = Vec::with_capacity(order_count as usize);
    for _ in 0..order_count {
        let flags = FlagDrawingOrder::from_bits_truncate(orders_data.read_u8()?);
        let order = if flags.contains(FlagDrawingOrder::TS_SECONDARY) {
            DrawingOrder::DrawingOrderSecondary(DrawingOrderSecondary::from_bytes(orders_data)?)
        } else if flags.contains(FlagDrawingOrder::TS_STANDARD) {
            DrawingOrder::PrimaryDrawingOrder(PrimaryDrawingOrder::from_bytes(
                orders_data,
                flags,
                orders_history,
            )?)
        } else if flags.contains(FlagDrawingOrder::TS_ALTERNATE) {
            DrawingOrder::AlternateSecondary
        } else {
            return Err(Error::RdpError(RdpError::new(
                RdpErrorKind::InvalidData,
                &format!("invalid order data type"),
            )));
        };
        debug!("order: {:?}", order);
        drawing_orders.push(order)
    }

    Ok(drawing_orders)
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_data_from_server() {
        let mut history = PrimaryDrawingOrderHistory::default();

        let mem = MemBlt {
            cache_id: 2,
            cache_index: 0,
            color_table_id: 0,
            n_left_rect: 1664,
            n_top_rect: 0,
            n_width: 64,
            n_height: 64,
            b_rop: 204,
            n_x_src: 0,
            n_y_src: 0,
        };

        history.mem_blt = Some(mem);
        history.order_type = Some(PrimaryOrderType::MemBlt);

        let mut data: Cursor<&[u8]> = Cursor::new(&[
            0x03, 0x1C, 0x00, 0xA2, 0x05, 0x05, 0x99, 0x4C, 0xD5, 0xB0, 0xFE, 0x79, 0x61, 0x9C,
            0x40, 0x40, 0x17, 0x00, 0x00, 0x1C, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0xF0, 0xBC, 0x0F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49,
            0x0D, 0x39, 0x02, 0x00, 0x40, 0x00, 0x40, 0x00, 0xCC, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x03, 0x1D, 0x00, 0x22, 0x05, 0x05, 0x6F, 0xAA, 0x84, 0x01, 0x5F,
            0xC6, 0xCC, 0x5F, 0x32, 0x40, 0x40, 0x17, 0x01, 0x00, 0x0E, 0x84, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x4A, 0x0C, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E, 0x01, 0x00,
            0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E, 0x01, 0x00, 0x00, 0x80,
            0x00, 0x40, 0x00, 0x00, 0x00, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x11,
            0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E, 0x01, 0x00, 0x00, 0xC0, 0x00, 0x40,
            0x00, 0x00, 0x00, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x11, 0x0A, 0x01,
            0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00,
            0x00, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2,
            0x01, 0x00, 0x01, 0x0E, 0x01, 0x00, 0x00, 0x40, 0x01, 0x40, 0x00, 0x00, 0x00, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00,
            0x01, 0x0E, 0x01, 0x00, 0x00, 0x80, 0x01, 0x40, 0x00, 0x00, 0x00, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E,
            0x01, 0x00, 0x00, 0xC0, 0x01, 0x40, 0x00, 0x00, 0x00, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E, 0x01, 0x00,
            0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E, 0x01, 0x00, 0x00, 0x40,
            0x02, 0x40, 0x00, 0x00, 0x00, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x11,
            0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E, 0x01, 0x00, 0x00, 0x80, 0x02, 0x40,
            0x00, 0x00, 0x00, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x11, 0x0A, 0x01,
            0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E, 0x01, 0x00, 0x00, 0xC0, 0x02, 0x40, 0x00, 0x00,
            0x00, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2,
            0x01, 0x00, 0x01, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x03, 0x40, 0x00, 0x00, 0x00, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00,
            0x01, 0x0E, 0x01, 0x00, 0x00, 0x40, 0x03, 0x40, 0x00, 0x00, 0x00, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E,
            0x01, 0x00, 0x00, 0x80, 0x03, 0x40, 0x00, 0x00, 0x00, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00, 0x01, 0x0E, 0x01, 0x00,
            0x00, 0xC0, 0x03, 0x40, 0x00, 0x00, 0x00, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x01, 0x00, 0x03, 0x1D, 0x00, 0x22, 0x05, 0x05,
            0x1E, 0x46, 0xFD, 0x24, 0x8A, 0x1D, 0xA1, 0xDC, 0x40, 0x16, 0x40, 0x17, 0x02, 0x00,
            0x1C, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3C, 0x05, 0x84,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1E, 0x01, 0x00, 0x00, 0x00,
            0x04, 0x40, 0x00, 0x16, 0x00, 0x02, 0x00, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51,
            0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40,
            0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02, 0x40, 0x51, 0x02,
            0x40, 0x03, 0x1D, 0x00, 0x22, 0x05, 0x05, 0x71, 0x8A, 0x73, 0x5C, 0x98, 0xF7, 0xDC,
            0xAD, 0x32, 0x16, 0x40, 0x17, 0x03, 0x00, 0x0E, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0xF0, 0x16, 0x04, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x11, 0x0A, 0x01, 0x40, 0xF2, 0x03, 0x00,
        ]);

        let orders = process_orders_data(480, &mut data, &mut history).unwrap();
    }

    #[test]
    fn test_sth() {
        let mut history = PrimaryDrawingOrderHistory::default();

        history.order_type = Some(PrimaryOrderType::ScrBlt);

        let mut data: Cursor<&[u8]> = Cursor::new(&
            // [9, 2, 127, 232, 2, 252, 0, 232, 3, 80, 1, 204, 232, 2, 240, 0]
            // [9, 2, 127, 96, 2, 116, 0, 100, 3, 76, 1, 204, 96, 2, 104, 0]
            // [9, 2, 127, 232, 2, 252, 0, 232, 3, 80, 1, 204, 232, 2, 240, 0]
            // [1, 111, 72, 1, 80, 0, 72, 3, 160, 0, 72, 1, 128, 1]
            // [1, 111, 161, 1, 137, 0, 36, 3, 228, 1, 248, 0, 72, 0]
            // [
                // 9, 2, 127, 232, 2, 252, 0, 232, 3, 80, 1, 204, 232, 2, 240, 0,     
            // 1, 111, 24, 4, 17, 2, 176, 0, 96, 0, 0, 4, 8, 2, 1, 45, 248, 0, 152, 2, 128, 0, 224, 0, 1, 78, 69, 0, 208, 3, 204, 1, 60, 0]


            [9, 2, 127, 232, 2, 252, 0, 232, 3, 80, 1, 204, 232, 2, 240, 0,
            1, 111, 83, 2, 127, 0, 132, 0, 24, 0, 100, 1, 104, 0, 1, 111, 223, 2, 187, 0, 220, 2, 36, 2, 240, 1, 164, 0, 1, 111, 191, 1, 151, 0, 24, 1, 72, 2, 208, 0, 128, 0]);
        let orders = process_orders_data(4, &mut data, &mut history).unwrap();

        assert_eq!(orders.len(), 4);
    }

    #[test]
    fn test_multiple_orders() {
        let mut history = PrimaryDrawingOrderHistory::default();
        let mut data: Cursor<&[u8]> = Cursor::new(&[
            0x03, 0xda, 0x00, 0xa1, 0x0c, 0x05, 0x20, 0x40, 0xdc, 0xff, 0xff, 0x85, 0xff, 0xff,
            0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x06, 0x8b, 0x99, 0xd6, 0x99, 0xd6,
            0x99, 0xd6, 0x10, 0x84, 0x08, 0x42, 0x08, 0x42, 0x10, 0x84, 0x99, 0xd6, 0x99, 0xd6,
            0x99, 0xd6, 0x99, 0xd6, 0x06, 0x84, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0xff, 0xff,
            0x16, 0x69, 0x99, 0xd6, 0x06, 0x69, 0x99, 0xd6, 0x04, 0xcc, 0x89, 0x52, 0x03, 0x6e,
            0xff, 0xff, 0x02, 0x6e, 0x08, 0x42, 0x01, 0x70, 0x08, 0x42, 0x71, 0xff, 0xff, 0xce,
            0x18, 0xc6, 0x01, 0x81, 0x08, 0x42, 0xce, 0x66, 0x29, 0x02, 0xcd, 0x89, 0x52, 0x03,
            0x88, 0x10, 0x84, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0xd8, 0x99, 0xd6, 0x03, 0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf0,
            0x66, 0x99, 0xd6, 0x05, 0x6a, 0x99, 0xd6, 0x00, 0xc4, 0xcc, 0x89, 0x52, 0x03, 0x6e,
            0xff, 0xff, 0x02, 0x6e, 0x08, 0x42, 0x01, 0x70, 0x08, 0x42, 0x71, 0xff, 0xff, 0xce,
            0x18, 0xc6, 0x01, 0x81, 0x08, 0x42, 0xce, 0x66, 0x29, 0x02, 0xcd, 0x89, 0x52, 0x03,
            0x00, 0x04, 0xd6, 0x99, 0xd6, 0xc3, 0x80, 0x61, 0x00, 0xa5, 0x80, 0x40, 0xec, 0x52,
            0x00, 0x5a, 0x00, 0x2d, 0x00, 0x24, 0x00, 0x12, 0x00, 0x24, 0x00, 0x12, 0x00, 0x5a,
            0x00, 0x2d, 0x00, 0xa5, 0x80, 0x52, 0x00, 0xc3, 0x80, 0x61, 0x00, 0x00, 0x00, 0x00,
            0x00, 0xcc, 0x89, 0x52, 0x03, 0x6e, 0xff, 0xff, 0x02, 0xcb, 0x18, 0xc6, 0x84, 0x08,
            0x42, 0x08, 0x42, 0x08, 0x42, 0xff, 0xff, 0x03, 0xda, 0x00, 0xa1, 0x0c, 0x05, 0x20,
            0x40, 0xdc, 0xff, 0xff, 0x85, 0xff, 0xff, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x99,
            0xd6, 0x06, 0x8b, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x10, 0x84, 0x08, 0x42, 0x08,
            0x42, 0x10, 0x84, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x06, 0x84, 0x99,
            0xd6, 0x99, 0xd6, 0x99, 0xd6, 0xff, 0xff, 0x16, 0x69, 0x99, 0xd6, 0x06, 0x69, 0x99,
            0xd6, 0x04, 0xcc, 0x89, 0x52, 0x03, 0x6e, 0xff, 0xff, 0x02, 0x6e, 0x08, 0x42, 0x01,
            0x70, 0x08, 0x42, 0x71, 0xff, 0xff, 0xce, 0x18, 0xc6, 0x01, 0x81, 0x08, 0x42, 0xce,
            0x66, 0x29, 0x02, 0xcd, 0x89, 0x52, 0x03, 0x88, 0x10, 0x84, 0x99, 0xd6, 0x99, 0xd6,
            0x99, 0xd6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x99, 0xd6, 0x03,
            0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x66, 0x99, 0xd6, 0x05, 0x6a, 0x99, 0xd6,
            0x00, 0xc4, 0xcc, 0x89, 0x52, 0x03, 0x6e, 0xff, 0xff, 0x02, 0x6e, 0x08, 0x42, 0x01,
            0x70, 0x08, 0x42, 0x71, 0xff, 0xff, 0xce, 0x18, 0xc6, 0x01, 0x81, 0x08, 0x42, 0xce,
            0x66, 0x29, 0x02, 0xcd, 0x89, 0x52, 0x03, 0x00, 0x04, 0xd6, 0x99, 0xd6, 0xc3, 0x80,
            0x61, 0x00, 0xa5, 0x80, 0x40, 0xec, 0x52, 0x00, 0x5a, 0x00, 0x2d, 0x00, 0x24, 0x00,
            0x12, 0x00, 0x24, 0x00, 0x12, 0x00, 0x5a, 0x00, 0x2d, 0x00, 0xa5, 0x80, 0x52, 0x00,
            0xc3, 0x80, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0x89, 0x52, 0x03, 0x6e, 0xff,
            0xff, 0x02, 0xcb, 0x18, 0xc6, 0x84, 0x08, 0x42, 0x08, 0x42, 0x08, 0x42, 0xff, 0xff,
        ]);

        let orders = process_orders_data(2, &mut data, &mut history).unwrap();
        assert_eq!(orders.len(), 2);
    }

    #[test]
    fn test_scr_blt() {
        let mut history = PrimaryDrawingOrderHistory::default();
        let mut data: Cursor<&[u8]> = Cursor::new(&[
            // 0x09, // flags
            0x02, 0x7d, 0x07, 0x00, 0xa1, 0x01, 0xf1, 0x00, 0xcc, 0x2f, 0x01, 0x8e, 0x00,
        ]);

        let order = match PrimaryDrawingOrder::from_bytes(
            &mut data,
            FlagDrawingOrder::from_bits_truncate(0x09),
            &mut history,
        )
        .unwrap()
        {
            PrimaryDrawingOrder::ScrBlt(order) => order,
            _ => panic!("panic"),
        };
    }

    #[test]
    fn test_primary_drawing_order_memblt() {
        let mut history = PrimaryDrawingOrderHistory::default();

        let mut data: Cursor<&[u8]> = Cursor::new(&[
            // 0x49, // flags
            0x0d, // order type
            0x97, 0xff, 0x00, 0x02, 0x00, 0x06, 0x01, 0x15, 0x00, 0x15, 0x00,
        ]);

        let order = match PrimaryDrawingOrder::from_bytes(
            &mut data,
            FlagDrawingOrder::from_bits_truncate(0x49),
            &mut history,
        )
        .unwrap()
        {
            PrimaryDrawingOrder::MemBlt(order) => order,
            _ => panic!("panic"),
        };

        assert_eq!(order.cache_id, 0xFF);
        assert_eq!(order.color_table_id, 0);

        assert_eq!(order.n_left_rect, 0x0002);
        assert_eq!(order.n_top_rect, 0x0106);
        // assert_eq!(n_width, None);
        assert_eq!(order.n_height, 0x0015);
        // assert_eq!(b_rop, None);
        // assert_eq!(n_x_src, None);
        assert_eq!(order.n_y_src, 0x0015);
        // assert_eq!(cache_index, None);

        history.order_type = Some(PrimaryOrderType::MemBlt);
        let mut data: Cursor<&[u8]> = Cursor::new(&[
            // 0x41, // flags
            // 0x0d, // order type
            0x97, 0x01, 0x00, 0x02, 0x00, 0x06, 0x01, 0x15, 0x00, 0x15, 0x00,
        ]);

        let order = match PrimaryDrawingOrder::from_bytes(
            &mut data,
            FlagDrawingOrder::from_bits_truncate(0x41),
            &mut history,
        )
        .unwrap()
        {
            PrimaryDrawingOrder::MemBlt(order) => order,
            _ => panic!("panic"),
        };

        assert_eq!(order.cache_id, 0x01);
    }

    #[test]
    fn test_secondary_drawing_order_cache_bitmap_rev2() {
        // 4.2.2 Cache Bitmap (Revision 2)
        // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpegdi/80eb9f88-30a9-4349-9972-5d97c6c5a2e0
        let mut data: Cursor<&[u8]> = Cursor::new(&[
            // let mut data: Cursor<Vec<u8>> = Cursor::new(vec![
            // 0x03 => controlFlags,
            0xda, 0x00, 0xa1, 0x0c, 0x05, 0x20, 0x40, 0xdc, 0xff, 0xff, 0x85, 0xff, 0xff, 0x99,
            0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x06, 0x8b, 0x99, 0xd6, 0x99, 0xd6, 0x99,
            0xd6, 0x10, 0x84, 0x08, 0x42, 0x08, 0x42, 0x10, 0x84, 0x99, 0xd6, 0x99, 0xd6, 0x99,
            0xd6, 0x99, 0xd6, 0x06, 0x84, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0xff, 0xff, 0x16,
            0x69, 0x99, 0xd6, 0x06, 0x69, 0x99, 0xd6, 0x04, 0xcc, 0x89, 0x52, 0x03, 0x6e, 0xff,
            0xff, 0x02, 0x6e, 0x08, 0x42, 0x01, 0x70, 0x08, 0x42, 0x71, 0xff, 0xff, 0xce, 0x18,
            0xc6, 0x01, 0x81, 0x08, 0x42, 0xce, 0x66, 0x29, 0x02, 0xcd, 0x89, 0x52, 0x03, 0x88,
            0x10, 0x84, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xd8, 0x99, 0xd6, 0x03, 0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x66,
            0x99, 0xd6, 0x05, 0x6a, 0x99, 0xd6, 0x00, 0xc4, 0xcc, 0x89, 0x52, 0x03, 0x6e, 0xff,
            0xff, 0x02, 0x6e, 0x08, 0x42, 0x01, 0x70, 0x08, 0x42, 0x71, 0xff, 0xff, 0xce, 0x18,
            0xc6, 0x01, 0x81, 0x08, 0x42, 0xce, 0x66, 0x29, 0x02, 0xcd, 0x89, 0x52, 0x03, 0x00,
            0x04, 0xd6, 0x99, 0xd6, 0xc3, 0x80, 0x61, 0x00, 0xa5, 0x80, 0x40, 0xec, 0x52, 0x00,
            0x5a, 0x00, 0x2d, 0x00, 0x24, 0x00, 0x12, 0x00, 0x24, 0x00, 0x12, 0x00, 0x5a, 0x00,
            0x2d, 0x00, 0xa5, 0x80, 0x52, 0x00, 0xc3, 0x80, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xcc, 0x89, 0x52, 0x03, 0x6e, 0xff, 0xff, 0x02, 0xcb, 0x18, 0xc6, 0x84, 0x08, 0x42,
            0x08, 0x42, 0x08, 0x42, 0xff, 0xff,
        ]);

        let raw_bitmap_data: Cursor<&[u8]> = Cursor::new(&[
            // let raw_bitmap_data: Cursor<Vec<u8>> = Cursor::new(vec![
            // 0x03 => controlFlags,
            // 0xda, 0x00, 0xa1, 0x0c, 0x05, 0x20, 0x40, 0xdc, 0xff, 0xff => header data,
            0x85, 0xff, 0xff, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x06, 0x8b, 0x99,
            0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x10, 0x84, 0x08, 0x42, 0x08, 0x42, 0x10, 0x84, 0x99,
            0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x06, 0x84, 0x99, 0xd6, 0x99, 0xd6, 0x99,
            0xd6, 0xff, 0xff, 0x16, 0x69, 0x99, 0xd6, 0x06, 0x69, 0x99, 0xd6, 0x04, 0xcc, 0x89,
            0x52, 0x03, 0x6e, 0xff, 0xff, 0x02, 0x6e, 0x08, 0x42, 0x01, 0x70, 0x08, 0x42, 0x71,
            0xff, 0xff, 0xce, 0x18, 0xc6, 0x01, 0x81, 0x08, 0x42, 0xce, 0x66, 0x29, 0x02, 0xcd,
            0x89, 0x52, 0x03, 0x88, 0x10, 0x84, 0x99, 0xd6, 0x99, 0xd6, 0x99, 0xd6, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x99, 0xd6, 0x03, 0xf8, 0x01, 0x00, 0x00,
            0x00, 0x00, 0xf0, 0x66, 0x99, 0xd6, 0x05, 0x6a, 0x99, 0xd6, 0x00, 0xc4, 0xcc, 0x89,
            0x52, 0x03, 0x6e, 0xff, 0xff, 0x02, 0x6e, 0x08, 0x42, 0x01, 0x70, 0x08, 0x42, 0x71,
            0xff, 0xff, 0xce, 0x18, 0xc6, 0x01, 0x81, 0x08, 0x42, 0xce, 0x66, 0x29, 0x02, 0xcd,
            0x89, 0x52, 0x03, 0x00, 0x04, 0xd6, 0x99, 0xd6, 0xc3, 0x80, 0x61, 0x00, 0xa5, 0x80,
            0x40, 0xec, 0x52, 0x00, 0x5a, 0x00, 0x2d, 0x00, 0x24, 0x00, 0x12, 0x00, 0x24, 0x00,
            0x12, 0x00, 0x5a, 0x00, 0x2d, 0x00, 0xa5, 0x80, 0x52, 0x00, 0xc3, 0x80, 0x61, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xcc, 0x89, 0x52, 0x03, 0x6e, 0xff, 0xff, 0x02, 0xcb, 0x18,
            0xc6, 0x84, 0x08, 0x42, 0x08, 0x42, 0x08, 0x42, 0xff, 0xff,
        ]);

        let dos = DrawingOrderSecondary::from_bytes(&mut data).unwrap();
        match dos {
            DrawingOrderSecondary::CacheBitmapCompressedRev2(cbc) => {
                assert_eq!(cbc.width, 0x20);
                assert_eq!(cbc.height, 0x20);
                assert_eq!(cbc.bits_per_pixel, 16);
                assert_eq!(cbc.cache_id, 0x1);
                assert_eq!(cbc.cache_index, BITMAPCACHE_WAITING_LIST_INDEX);
                assert_eq!(&cbc.data, raw_bitmap_data.get_ref());
            }
            _ => panic!("wrong order type"),
        };
    }

    #[test]
    fn test_byte_encoding() {
        assert_eq!(
            two_byte_unsigned(&mut Cursor::new([0x9A, 0x1B])).unwrap(),
            0x1A1B,
        );

        assert_eq!(
            two_byte_unsigned(&mut Cursor::new([0x9A, 0x1B, 0xFF, 0xFF])).unwrap(),
            0x1A1B,
        );

        assert_eq!(
            four_byte_unsigned(&mut Cursor::new([0x9A, 0x1B, 0x1C])).unwrap(),
            0x001A1B1C,
        );

        assert_eq!(
            four_byte_unsigned(&mut Cursor::new([0x9A, 0x1B, 0x1C, 0xFF, 0xFF])).unwrap(),
            0x001A1B1C,
        );

        assert_eq!(
            four_byte_unsigned(&mut Cursor::new([0xFF, 0xFF, 0xFF, 0xFF])).unwrap(),
            0x3FFFFFFF,
        );
    }
}
